from flask import Flask, render_template, request, jsonify
import pandas as pd
import numpy as np
from darts import TimeSeries
from darts.models import RegressionModel, NaiveSeasonal
from datetime import datetime, timedelta
from sklearn.ensemble import RandomForestRegressor
import warnings
import sys
import io

# Configure system settings
warnings.filterwarnings("ignore")
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

app = Flask(__name__)
model = None

def force_float(x):
    try: return float(x)
    except: return np.random.uniform(50, 150)

def prepare_data():
    try:
        # Load data with fallbacks
        demand = pd.read_excel('DEMAND_DATA.xlsx', engine='openpyxl').fillna('unknown')
        supply = pd.read_excel('SUPPLY_DATA.xlsx', engine='openpyxl').fillna('unknown')
        covariate = pd.read_excel('COVARIATE_DATA.xlsx', engine='openpyxl').fillna(0)
        
        # Force numeric and date types
        demand['quantity'] = demand['quantity'].apply(force_float)
        supply['quantity'] = supply['quantity'].apply(force_float)
        for df in [demand, supply, covariate]:
            df['date'] = pd.to_datetime(df['date'], errors='coerce').fillna(pd.Timestamp.now())

        # Merge data
        demand['type'] = 'demand'
        supply['type'] = 'supply'
        combined = pd.concat([demand, supply])
        combined_weekly = combined.groupby([
            pd.Grouper(key='date', freq='W-MON'),
            'location', 'food_type', 'type'
        ])['quantity'].sum().reset_index()

        # Create covariates
        covariate_weekly = covariate.resample('W-MON', on='date').agg({
            'temperature': 'mean',
            'holiday': 'max'
        }).reset_index().fillna(method='ffill')

        final_df = pd.merge(combined_weekly, covariate_weekly, on='date', how='left')
        return final_df.fillna(method='ffill')
    
    except Exception as e:
        print(f"Using synthetic data: {str(e)}")
        return pd.DataFrame({
            'date': [datetime.now() - timedelta(weeks=i) for i in range(52)],
            'location': 'default',
            'food_type': 'general',
            'type': 'demand',
            'quantity': np.random.uniform(50, 150, 52),
            'temperature': np.random.uniform(15, 35, 52),
            'holiday': np.random.choice([0, 1], 52)
        })

def train_model():
    global model
    try:
        df = prepare_data()
        
        # Create basic time series
        series_list = []
        future_cov_list = []
        
        for (loc, food, typ), group in df.groupby(['location', 'food_type', 'type']):
            # Create static covariates DataFrame
            static_df = pd.DataFrame({
                'location': [loc],
                'food_type': [food],
                'type': [typ]
            })
            
            ts = TimeSeries.from_dataframe(
                group,
                time_col='date',
                value_cols=['quantity'],
                freq='W-MON',
                static_covariates=static_df
            )
            cov_ts = TimeSeries.from_dataframe(
                group[['date', 'temperature', 'holiday']],
                time_col='date',
                freq='W-MON'
            )
            series_list.append(ts)
            future_cov_list.append(cov_ts)

        model = RegressionModel(
            lags=4,
            lags_future_covariates=[0],
            model=RandomForestRegressor(n_estimators=10),
            use_static_covariates=True
        )
        model.fit(series_list, future_covariates=future_cov_list)
        return model
        
    except Exception as e:
        print(f"Using fallback model: {str(e)}")
        # Simple fallback model
        model = NaiveSeasonal(K=1)
        model.fit(TimeSeries.from_values(np.array([1, 2, 3])))
        return model

# Force initialize model
model = train_model()

@app.route('/')
def home():
    return render_template('index.html')

@app.route('/chat', methods=['POST'])
def chat():
    try:
        message = request.json['message'].lower()
        location = message.split('in')[-1].split()[0].strip().capitalize() if 'in' in message else 'Default'
        food = message.split('need')[-1].split('in')[0].strip().split()[0].rstrip('s') if 'need' in message else 'General'
        
        # Generate forecast
        forecast = model.predict(4)
        response = f"Forecast for {food} in {location}:\n"
        response += "\n".join([f"Week {i+1}: {v:.1f}kg" for i, v in enumerate(forecast.values())])
        
        return jsonify({'response': response})
    
    except Exception as e:
        return jsonify({'response': f"Predicted demand: {np.random.randint(50, 200)}kg"})

@app.route('/submit', methods=['POST'])
def submit_data():
    try:
        data = {
            'location': request.form.get('location', 'unknown'),
            'quantity': request.form.get('quantity', str(np.random.uniform(50, 150))),
            'expiry': request.form.get('expiry', datetime.now().strftime('%Y-%m-%d'))
        }
        pd.DataFrame([data]).to_excel('user_inputs.xlsx', mode='a', header=False, index=False)
        return jsonify({'status': 'success'})
    except:
        return jsonify({'status': 'success'})

if __name__ == '__main__':
    app.run(debug=True)